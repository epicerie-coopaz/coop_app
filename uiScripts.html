<script type="module">
  const anchorEl = document.body.querySelector('#usage-submenu-anchor');
  const menuEl = document.body.querySelector('#usage-submenu');

  anchorEl.addEventListener('click', () => { menuEl.open = !menuEl.open; });
</script>
<script>
    function loadContent(sectionId) {
        // Masquer toutes les sections
        const sections = document.querySelectorAll('.content-section');
        sections.forEach(section => section.classList.remove('active'));

        // Afficher la section correspondante
        const selectedSection = document.getElementById(sectionId);
        selectedSection.classList.add('active');

        // Modifier le titre du header en fonction de la section
        const headerTitle = document.getElementById('header-title');
        switch (sectionId) {
            case 'home':
                headerTitle.textContent = 'Page d\'Accueil';
                break;
            case 'vente':
                headerTitle.textContent = 'Gestion des ventes';
                getProductsFromSheet();
                getProducts();
                addRow();
                getAdherents();
                getCotisations();
                break;
            case 'reception':
                headerTitle.textContent = 'Réception des Produits';
                loadSuppliers();
                break;
            case 'suppliers':
                headerTitle.textContent = 'Liste des Fournisseurs';
                getfournisseur();
                break;
            case 'perte':
                headerTitle.textContent = 'Gestion des pertes';
                getProducts();
                addRowPertes();
                break;
            case 'inventaire':
                headerTitle.textContent = 'Inventaire';
                getProducts();
                break;
            case 'etiquettes':
                headerTitle.textContent = 'Gestion des pertes';
                getProducts();
                addRowEtiquettes();
                break;
        }
    }

   function requestAccess(page) {
    // Demander un code d'accès
    var accessCode = prompt("Veuillez entrer le code d'accès pour accéder à l'Inventaire:");

    // Vérifier si le code d'accès est correct
    var correctCode = "inventaireCoop'az"; // Remplacer par le code d'accès réel

    if (accessCode === correctCode) {
        // Accéder à la page de l'inventaire
        loadContent(page);
    } else {
        // Afficher un message d'erreur si le code est incorrect
        alert("Code incorrect. Vous n'êtes pas autorisé à accéder à cette page.");
    }
  }


    ///////////UI////////////

  function showLoader(customText = 'Ouverture du logiciel en cours') {
    const loader = document.createElement('div');
    loader.id = 'loader';
    loader.style.position = 'fixed';
    loader.style.top = '0';
    loader.style.left = '0';
    loader.style.width = '100%';
    loader.style.height = '100%';
    loader.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    loader.style.display = 'flex';
    loader.style.alignItems = 'center';
    loader.style.justifyContent = 'center';
    loader.style.zIndex = '1000';

    // Personnalisation du texte
    loader.innerHTML = `<h2>${customText}</h2><div class="spinner"></div>`;
    document.body.appendChild(loader);
}

    function hideLoader() {
        const loader = document.getElementById('loader');
        if (loader) {
            document.body.removeChild(loader);
        }
    }

    function getProducts() {
        showLoader('Chargement des produits');
        google.script.run.withSuccessHandler(function (data) {
            products = data;
        console.log('Produits mis à jour:', products);
            hideLoader();
        }).getProducts();
    }

    function getAdherents() {
        google.script.run.withSuccessHandler(function (data) {
            adherents = data;
            const adherentsDropdown = document.getElementById('adherentsDropdown');
            adherentsDropdown.innerHTML = '<option value="">Sélectionner un adhérent</option>';
            adherents.forEach(adherent => {
                const option = document.createElement('option');
                option.value = adherent.name; // Utilise le nom comme valeur
                option.textContent = adherent.name;
                adherentsDropdown.appendChild(option);
            });

            // Initialiser Select2
            $(adherentsDropdown).select2({
                placeholder: 'Sélectionnez un adhérent',
                allowClear: true
            });


            // Ajouter le focus au champ de recherche lorsque la liste est ouverte
            $(adherentsDropdown).on('select2:open', () => {
                document.querySelector('.select2-search__field').focus();
            });


        }).getAdherents();
    }

    // Fonction pour ouvrir la popup de sélection
function openCreateAdherentPopup() {
     const popupHtml = `
      <div class="popup-overlay">
        <div class="popup-content">
          <h2>Créer un utilisateur</h2>
          <form id="choiceForm">
            <div id="userSelection">
              <p>Type d'utilisateur :</p>
              <div>
                <input type="radio" id="userAdherent" name="userType" value="adherent">
                <label for="userAdherent">Créer un adhérent</label>
              </div>
              <div>
                <input type="radio" id="userPartner" name="userType" value="partenaire">
                <label for="userPartner">Partenaire</label>
              </div>
               <div>
                <input type="radio" id="userPartner" name="userType" value="partenaire">
                <label for="userPartner">Adhérent en cours d'adhésion</label>
              </div>
              </br>
              </br>
              <button type="button" onclick="handleNext()">Suivant</button>
              <button type="button" onclick="closePopup()">Annuler</button>
            </div>
            <div id="formFields"></div>
          </form>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', popupHtml);
}

// Fonction pour fermer la popup
function closePopup() {
    const overlay = document.querySelector('.popup-overlay');
    if (overlay) overlay.remove();
}

// Fonction pour gérer l'étape suivante
function handleNext() {
    const userType = document.querySelector('input[name="userType"]:checked');
    const userSelection = document.getElementById('userSelection');
    const formFields = document.getElementById('formFields');

    if (userType) {
        // Masquer la sélection initiale et les boutons
        userSelection.style.display = 'none';

        // Afficher les champs correspondants
       if (userType.value === 'adherent') {
    formFields.innerHTML = `
    <h2> Nouvel adhérent</h2>
        <label for="nouvelAdherentName">Nom</label>
        <input type="text" id="nouvelAdherentName" required><br><br>
        <label for="nouvelAdherentFirstName">Prénom</label>
        <input type="text" id="nouvelAdherentFirstName" required><br><br>
        <label for="nouvelAdherentEmail">Email</label>
        <input type="email" id="nouvelAdherentEmail" required><br><br>
        <label for="nouvelAdherentPhone">Téléphone</label>
        <input type="tel" id="nouvelAdherentPhone" required><br><br>
        <label for="nouvelAdherentAddress">Adresse</label>
        <input type="text" id="nouvelAdherentAddress" required><br><br>
        <label for="meetingDates">Date de la réunion</label><br>
        <div id="meetingDates">
            <label><input type="checkbox" value="lundi"> Lundi 19h-21h</label><br>
            <label><input type="checkbox" value="mardi"> Mardi 19h-21h</label><br>
            <label><input type="checkbox" value="mercredi"> Mercredi 19h-21h</label><br>
            <label><input type="checkbox" value="jeudi"> Jeudi 19h-21h</label><br>
            <label><input type="checkbox" value="vendredi"> Vendredi 19h-21h</label><br>
            <label><input type="checkbox" value="samedi"> Samedi 14h-16h</label><br>
        </div><br>
        <button type="button" onclick="saveAdherent()">Valider</button>
        <button type="button" onclick="closePopup()">Annuler</button>
    `;
} else if (userType.value === 'partenaire') {
            formFields.innerHTML = `
            <h2> Partenaire</h2>
              <label for="partnerName">Nom</label>
              <input type="text" id="partnerName" required><br><br>
              <label for="partnerEmail">Email</label>
              <input type="email" id="partnerEmail" required><br><br>
              <button type="button" onclick="savePartner()">Valider</button>
              <button type="button" onclick="closePopup()">Annuler</button>
            `;
        }
    } else {
        alert("Veuillez sélectionner une option avant de continuer.");
    }
}
function saveAdherent() {
    const nameField = document.getElementById('nouvelAdherentName');
    const firstNameField = document.getElementById('nouvelAdherentFirstName');
    const emailField = document.getElementById('nouvelAdherentEmail');
    const phoneField = document.getElementById('nouvelAdherentPhone');
    const addressField = document.getElementById('nouvelAdherentAddress');
    const meetingDatesField = document.getElementById('meetingDates');

    if (nameField && firstNameField && emailField && phoneField && addressField && meetingDatesField) {
        const name = nameField.value.trim();
        const firstName = firstNameField.value.trim();
        const email = emailField.value.trim();
        const phone = phoneField.value.trim();
        const address = addressField.value.trim();
        const meetingDates = Array.from(meetingDatesField.querySelectorAll('input[type="checkbox"]:checked')).map(option => option.value);

        if (name && firstName && email && phone && address) {
            // Ajouter l'adhérent à la liste en mémoire
            adherents.unshift({ name: `${firstName} ${name}`, email: email, isNew: true });

            const adherentData = {
                name: `${firstName} ${name}`,
                email: email,
                phone: phone,
                address: address,
                meetingDates: meetingDates
            };

            // Appeler la fonction backend pour envoyer l'email
            google.script.run.withSuccessHandler(() => {
                console.log("Adhérent créé et email envoyé.");

                // Appeler la fonction pour sauvegarder l'adhérent dans Google Sheets
                saveAdherentToSheet(`${firstName} ${name}`, email, phone, address);

                closePopup();
                updateDropdown();
            }).withFailureHandler((error) => {
                console.error("Erreur lors de l'envoi de l'email :", error);
                alert("Une erreur s'est produite lors de l'envoi de l'email.");
            }).sendAdherentEmail(adherentData);

        } else {
            alert("Veuillez remplir tous les champs.");
        }
    } else {
        alert("Erreur : certains champs sont introuvables.");
    }
}

// Fonction pour enregistrer l'adhérent dans la feuille "Recap"
function saveAdherentToSheet(name, email, phone, address) {
    google.script.run.withSuccessHandler(() => {
        console.log("Données sauvegardées avec succès dans la feuille Google Sheets.");
    }).withFailureHandler((error) => {
        console.error("Erreur lors de la sauvegarde dans Google Sheets : ", error);
    }).saveNewAdherent(name, email, phone, address);
}

// Fonction pour sauvegarder un partenaire
function savePartner() {
    const nameField = document.getElementById('partnerName');
    const emailField = document.getElementById('partnerEmail');

    if (nameField && emailField) {
        const name = nameField.value.trim();
        const email = emailField.value.trim();

        if (name && email) {
            // Ajouter le partenaire à la liste en mémoire
            adherents.unshift({ name: name, email: email, isNew: true }); // Ici, on utilise 'unshift' pour ajouter au début
            console.log('Partenaire sauvegardé :', { name, email });
            closePopup();
            updateDropdown(); // Mettre à jour la liste déroulante
        } else {
            alert("Veuillez remplir tous les champs.");
        }
    } else {
        alert("Erreur : certains champs sont introuvables.");
    }
}
/// Fonction pour mettre à jour la liste déroulante des adhérents
function updateDropdown() {
    const adherentsDropdown = document.getElementById('adherentsDropdown');
    
    // Réinitialiser la liste déroulante
    adherentsDropdown.innerHTML = '<option value="">Sélectionner un adhérent</option>';

    // Ajouter le nouvel adhérent (en premier) et les anciens adhérents à la liste déroulante
    adherents.forEach(adherent => {
        const option = document.createElement('option');
        option.value = adherent.name; // Utiliser le nom comme valeur
        option.textContent = adherent.name; // Afficher uniquement le nom
        adherentsDropdown.appendChild(option);
    });

    // Initialiser Select2
    $(adherentsDropdown).select2({
        placeholder: 'Sélectionnez un adhérent',
        allowClear: true
    });

    // Ajouter le focus au champ de recherche lorsque la liste est ouverte
    $(adherentsDropdown).on('select2:open', () => {
        document.querySelector('.select2-search__field').focus();
    });
}


    ///////////////////////////
    ///////////////////////////
    ///////vente///////////////
    ///////////////////////////
    ///////////////////////////

    function getCotisations() {
        google.script.run.withSuccessHandler(function (data) {
            cotisations = data; // 'data' doit contenir un objet avec les informations de cotisation
        }).getCotisations(); // Assure-toi que cette fonction soit bien définie dans le backend
    }


function updateEmail() {
    const selectedAdherentName = document.getElementById('adherentsDropdown').value;

    // Vérifier si un nom d'adhérent a été sélectionné
    if (selectedAdherentName) {
        // Trouver l'adhérent correspondant au nom sélectionné
        const selectedAdherent = adherents.find(adherent => adherent.name === selectedAdherentName);

        if (selectedAdherent) {
            const emailDiv = document.getElementById('adherentEmail');
            emailDiv.innerText = `Email: ${selectedAdherent.email}`;

            // Si l'adhérent est nouveau, ne pas vérifier la cotisation
            if (selectedAdherent.isNew) {
                emailDiv.style.color = "black"; // Couleur normale pour un nouveau partenaire
                document.getElementById('cotisationContainer').style.display = "none"; // Ne pas afficher la cotisation
            } else {
                // Vérification de la cotisation dans l'onglet "cotisations" pour les anciens adhérents
                const currentMonthYear = new Date().toLocaleString('fr-FR', { month: 'long', year: 'numeric' });
                const cotisationStatus = cotisations[selectedAdherentName]?.[currentMonthYear];

                if (cotisationStatus === "ok") {
                    emailDiv.style.color = "var(--md-sys-color-primary)";
                    document.getElementById('cotisationContainer').style.display = "none"; // Cacher le champ
                } else {
                    emailDiv.style.color = "red"; // Changer le texte en rouge
                    emailDiv.innerText += `\nN'a pas encore cotisé ce mois`;
                    document.getElementById('cotisationContainer').style.display = "flex"; // Afficher le champ
                }
            }
        }
    } else {
        // Si aucun adhérent n'est sélectionné
        document.getElementById('adherentEmail').innerText = '';  // Réinitialiser l'email
        document.getElementById('cotisationContainer').style.display = "none"; // Cacher le champ
    }
}


    function sortProducts(products) {

       if (!products || products.length === 0) {
        console.warn("La liste des produits est vide ou non définie.");
        return [];
    }
        // Trier les produits : d'abord par stock, puis par nom
        return products.sort((a, b) => {
            if (a.stock === 0 && b.stock === 0) {
                return 0; // Les deux sont hors stock
            } else if (a.stock <= 0) {
                return 1; // 'a' est hors stock, donc on le met en bas
            } else if (b.stock <= 0) {
                return -1; // 'b' est hors stock, donc on le met en bas
            }
            return a.name.localeCompare(b.name); // Trier par ordre alphabétique
        });
    }


  function addRow() {
    const productList = document.getElementById('productList').getElementsByTagName('tbody')[0];
    const row = productList.insertRow();
    row.style.opacity = 0;
    const cell1 = row.insertCell(0); // Colonne produit
    const cell2 = row.insertCell(1); // Colonne prix
    const cell3 = row.insertCell(2); // Colonne stock
    const cell4 = row.insertCell(3); // Colonne quantité
    const cell5 = row.insertCell(4); // Colonne discount
    const cell6 = row.insertCell(5); // Colonne total
    const cell7 = row.insertCell(6); // Colonne supprimer
    const cell8 = row.insertCell(7); // Colonne modifier le stock

    // Animation de glissement
    setTimeout(() => {
        row.style.opacity = 1;
    }, 10);
    
    const select = document.createElement('select');
    select.classList.add('product-select');
    select.innerHTML = `<option value="">Sélectionner un produit</option>`;
    const sortedProducts = sortProducts(products);
    sortedProducts.forEach(product => {
        const option = document.createElement('option');
        option.value = product.price;
        option.dataset.price = product.price;
        option.dataset.stock = product.stock;
        option.dataset.name = product.name;
        option.dataset.shortName = product.shortName;
        option.dataset.barcode = product.barcode;
        option.textContent = product.name;

        if (product.stock <= 0) {
            option.classList.add('out-of-stock');
        }
        select.appendChild(option);
    });

    cell1.appendChild(select);

    $(select)
    .select2({
        placeholder: 'Recherchez un produit',
        allowClear: true,
        matcher: function (params, data) {
            if ($.trim(params.term) === '') {
                return data;
            }

            // Fonction pour supprimer les accents
            function removeAccents(str) {
                const accentMap = {
                    'a': 'á|à|ã|â|ä|å|æ|ã|ā',
                    'e': 'é|è|ê|ë|ē|ė',
                    'i': 'í|ì|î|ï|ī',
                    'o': 'ó|ò|ô|ö|õ|ø|ō',
                    'u': 'ú|ù|û|ü|ū',
                    'c': 'ç',
                    'n': 'ñ',
                    's': 'ś|š',
                    'z': 'ź|ž'
                };

                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Supprimer les accents
            }

            const searchWords = params.term.toLowerCase().split(/\s+/).map(word => removeAccents(word));
            const dataText = removeAccents(data.text.toLowerCase());

            const match = searchWords.every(word => dataText.includes(word));
            return match ? data : null;
        },
        templateResult: function (option) {
            if ($(option.element).hasClass('out-of-stock')) {
                return $('<span style="color:red;">' + option.text + ' (Stock négatif)</span>');
            }
            return option.text;
        }
    })
    .on('select2:open', () => {
        document.querySelector('.select2-search__field').focus(); // Focus dans la zone de recherche
    });

    // Gestion de la sélection du produit
    select.onchange = function () {
        const selectedOption = select.selectedOptions[0];

        const formattedPrice = selectedOption ? parseFloat(selectedOption.dataset.price).toFixed(2) : '0.00';
        cell2.innerText = `${formattedPrice} €`;

        if (selectedOption) {
            let stockText = `${selectedOption.dataset.stock}`;
            if (selectedOption.dataset.name.toLowerCase().includes("unite")) {
                stockText = Math.round(parseFloat(selectedOption.dataset.stock)); // Arrondir à l'entier le plus proche
            } else {
                stockText = parseFloat(selectedOption.dataset.stock).toFixed(2);
            }

            if (selectedOption.dataset.name.toLowerCase().includes("litres")) {
                cell3.innerText = `${stockText} litres`;
            } else if (selectedOption.dataset.name.toLowerCase().includes("unite")) {
                cell3.innerText = `${stockText} unités`;
            } else if (selectedOption.dataset.name.toLowerCase().includes("kilo")) {
                cell3.innerText = `${stockText} Kg`;
            } else {
                cell3.innerText = `${stockText} unités`;
            }
            
            if (selectedOption.dataset.name.toLowerCase().includes("retour")) {
                cell3.innerText = "";
                row.style.backgroundColor = '#fdd';
            } else {
                row.style.backgroundColor = '';
            }

            // Enregistrement du shortName et barcode
            const shortName = selectedOption.dataset.shortName;
            const barcode = selectedOption.dataset.barcode;


            // Incrémentation de la quantité si produit "unite"
            if (selectedOption.dataset.name.toLowerCase().includes("unite")) {
                const quantityInput = cell4.querySelector('input');
                quantityInput.value = parseInt(quantityInput.value) + 1; // Incrémentation de la quantité
                calculateRowTotal(row);
                addRow();
                setTimeout(() => {
                    const lastRowSelect = productList.rows[productList.rows.length - 1].cells[0].querySelector('select');
                    $(lastRowSelect).select2('open');
                    document.querySelector('.select2-search__field').focus();
                }, 10);
            } else {
                calculateRowTotal(row);
                addRow();
            }
        } else {
            cell3.innerText = "0.00 unités";
        }
    };

    const quantityInput = document.createElement('input');
    quantityInput.type = 'number';
    quantityInput.value = 0;
    quantityInput.step = 1;
    quantityInput.min = 0;

    quantityInput.oninput = function () {
        const selectedOption = select.selectedOptions[0];
        if (selectedOption && selectedOption.dataset.name.toLowerCase().includes("unite")) {
            if (quantityInput.value.includes('.')) {
                alert("La quantité d'un produit contenant 'unite' doit être un entier.");
                quantityInput.value = Math.floor(quantityInput.value);
            }
            quantityInput.step = 1;
        } else {
            quantityInput.step = 0.01;
        }
        calculateRowTotal(row);
    };

    cell4.appendChild(quantityInput);

    const discountInput = document.createElement('input');
    discountInput.type = 'number';
    discountInput.value = 0;
    discountInput.step = 0.01;
    discountInput.min = 0;

    discountInput.oninput = function () {
        let discountValue = parseFloat(discountInput.value);
        if (!isNaN(discountValue)) {
            discountInput.value = discountValue;
        } else {
            discountInput.value = 0;
        }
        calculateRowTotal(row);
    };

    cell5.appendChild(discountInput);

    cell6.innerText = '0.00 €';

    const deleteIcon = document.createElement('span');
    deleteIcon.innerHTML = '❌';
    deleteIcon.style.cursor = 'pointer';
    deleteIcon.onclick = function () {
        deleteRow(row);
    };
    cell7.appendChild(deleteIcon);

    const editIcon = document.createElement('span');
    editIcon.innerHTML = '✏️';
    editIcon.style.cursor = 'pointer';
    editIcon.onclick = function () {
        openStockPopup(select.selectedOptions[0]);
    };
    cell8.appendChild(editIcon);
}


    function deleteRow(row) {
        if (confirm("Êtes-vous sûr de vouloir supprimer cette ligne ?")) {
            const productList = document.getElementById('productList').getElementsByTagName('tbody')[0];
            productList.deleteRow(row.rowIndex - 1);
            calculateTotal();
        }
    }
    function calculateRowTotal(row) {
        const select = row.cells[0].querySelector('select');
        const quantityInput = row.cells[3].querySelector('input');
        const discountInput = row.cells[4].querySelector('input');
        const price = select ? parseFloat(select.value) : 0;
        const quantity = quantityInput ? parseFloat(quantityInput.value) : 0; // Remplacer parseInt par parseFloat
        const discount = discountInput ? parseFloat(discountInput.value) : 0; // Remplacer parseInt par parseFloat
        row.cells[5].innerText = `${(price * quantity - (price * quantity * (discount / 100))).toFixed(2)} €`; // Mettre à jour le total de la ligne
        calculateTotal(); // Recalculer le total général
    }

    // Fonction pour afficher ou masquer le champ de l'avoir
       function toggleCreditField() {
    const creditField = document.getElementById("creditField");
    const creditAmount = document.getElementById('creditAmount');
    if (document.getElementById("hasCredit").checked) {
        creditField.style.display = "block"; // Afficher le champ de l'avoir
    } else {
        creditField.style.display = "none"; // Masquer le champ de l'avoir
        creditAmount.value = ''; // Réinitialiser le montant de l'avoir
        calculateTotal(); // Recalculer le total sans l'avoir
    }
}

    function calculateTotal() {
    const rows = document.querySelectorAll('#productList tbody tr');
    let total = 0;
    rows.forEach(row => {
        const totalCell = row.cells[5].innerText;
        total += parseFloat(totalCell.replace(' €', '')) || 0;
    });
    
    // Ajouter le montant de la cotisation
    const creditAmount = parseFloat(document.getElementById('creditAmount').value) || 0;
    total -= creditAmount; // Ajouter le montant de cotisation au total
   
    // Ajouter le montant de la cotisation
    const cotisationAmount = parseFloat(document.getElementById('cotisationAmount').value) || 0;
    total += cotisationAmount; // Ajouter le montant de cotisation au total
   
    document.getElementById('total').innerText = `Total Général: ${total.toFixed(2)} €`;
     // Ajoute le coût CB si nécessaire
  const paymentMethod = document.getElementById('paymentMethodDropdown').value;
  let cbFee = 0;
  if (paymentMethod === "CB") {
    cbFee = total * 0.0055; // 0.55% de frais
    document.getElementById('cbFee').style.display = 'block';
    document.getElementById('cbFee').textContent = `Coût supplémentaire CB: ${cbFee.toFixed(2)} €`;
  } else {
    document.getElementById('cbFee').style.display = 'none';
  }

  // Total avec frais CB si appliqué
  const grandTotal = total + cbFee;
  document.getElementById('total').textContent = `Total Général: ${grandTotal.toFixed(2)} €`;
}








function validate() {
    showLoader('Validation de la facture');
   
    const adherent = document.getElementById('adherentsDropdown').value;
    const paymentMethod = document.getElementById('paymentMethodDropdown').value;
    const total = parseFloat(document.getElementById('total').innerText.replace('Total Général: ', '').replace(' €', ''));
    const dateTime = new Date().toISOString();
    const cotisationAmount = parseFloat(document.getElementById('cotisationAmount').value) || 0; // Récupérer le montant de cotisation
    const creditAmount = parseFloat(document.getElementById('creditAmount').value) || 0; // Récupérer le montant de cotisation
    const purchases = [];
    const rows = document.querySelectorAll('#productList tbody tr');
   
    // Renommer la variable pour éviter le conflit
    const invoiceRows = document.querySelectorAll('#productList tbody tr');
    for (const row of invoiceRows) {
        const select = row.cells[0].querySelector('select');
        const quantityInput = row.cells[3].querySelector('input');
        const discountInput = row.cells[4].querySelector('input'); // Champ de remise (assurez-vous que la remise est dans la 5ème colonne)
        const quantity = parseFloat(quantityInput.value) || 0; // Utiliser parseFloat pour permettre les quantités décimales
        const discount = parseFloat(discountInput.value) || 0; // Récupérer la remise
        // Vérifier que le produit est sélectionné avant de vérifier la quantité
        if (select.value && quantity === 0) {
            alert("Veuillez entrer une quantité supérieure à 0 pour tous les produits sélectionnés.");
            hideLoader(); // Cacher le loader si l'alerte est déclenchée
            return; // Sortir de la fonction si une quantité est 0
        }
    }
   
    if (!adherent || !paymentMethod || total <= 0) {
        alert('Veuillez remplir tous les champs requis.');
        hideLoader(); // Cacher le loader si des champs sont manquants
        return; // Sortir de la fonction si un champ est manquant
    }
   
    let orderDetails = ''; // Initialiser la variable pour stocker les détails
    rows.forEach(row => {
        const select = row.cells[0].querySelector('select');
        const quantityInput = row.cells[3].querySelector('input');
        const discountInput = row.cells[4].querySelector('input'); // Remise pour chaque ligne
        const productName = select.options[select.selectedIndex].dataset.name; // Récupérer le nom du produit
        const quantity = parseFloat(quantityInput.value) || 0; // Utiliser parseFloat pour permettre les quantités décimales
        const discount = parseFloat(discountInput.value) || 0; // Remise sur le produit
        const price = parseFloat(select.value) || 0; // Utiliser parseFloat pour permettre les prix décimaux
        const lineTotalBeforeDiscount = price * quantity;
        const discountAmount = (lineTotalBeforeDiscount * discount) / 100; // Calcul de la remise en pourcentage
        const totalLine = (lineTotalBeforeDiscount - discountAmount).toFixed(2); // Appliquer la remise et calculer le total de la ligne
       
        if (productName && quantity > 0) {
            purchases.push({
                productName: productName,
                quantity: quantity,
                price: price, // Ajouter le prix au produit
                discount: discount, // Ajouter la remise dans les achats
                modifiedStock: -quantity // Enregistrer une valeur négative pour diminuer le stock
            });
           
            // Construire le détail de la commande avec ou sans remise
            if (discount > 0) {
                orderDetails += `${productName} - ${quantity} x ${price.toFixed(2)} €  = ${lineTotalBeforeDiscount.toFixed(2)} € (Remise: ${discount.toFixed(2)}%) = ${totalLine} €\n`;
            } else {
                orderDetails += `${productName} - ${quantity} x ${price.toFixed(2)} €  = ${lineTotalBeforeDiscount.toFixed(2)} € = ${totalLine} €\n`;
            }
        }
    });




    google.script.run.withSuccessHandler(() => {
        console.log('Vente enregistrée et cotisation mise à jour');
        const currentMonthYear = new Date().toLocaleString('fr-FR', { month: 'long', year: 'numeric' });
        const cotisationStatus = cotisations[adherent]?.[currentMonthYear];
        if (cotisationStatus !== "ok") {
            // Met à jour la cotisation seulement si elle n'est pas à jour
            google.script.run.updateCotisation(adherent, currentMonthYear, cotisationAmount);
        }

        // Construction de l'email
        const invoiceEmail = `
            <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                <p>Bonjour,</p>
                <p>Vous trouverez ci-dessous votre dernière vente Coop'az.</p>
                <h2 style="color: #4CAF50;">vente</h2>
                <p><strong>Adhérent :</strong> ${adherent}</p>
                <p><strong>Date :</strong> ${new Date().toLocaleString('fr-FR')}</p>
                 <h3>Détails de la commande :</h3>
                <pre>${orderDetails}</pre> <!-- Utilisez un <pre> pour conserver la mise en forme -->
                ${cotisationAmount > 0 ? `<p><strong>Montant de la cotisation :</strong> ${cotisationAmount.toFixed(2)} €</p>` : ''}
                ${creditAmount > 0 ? `<p><strong>Montant de l'avoir :</strong> ${creditAmount.toFixed(2)} €</p>` : ''}
                <h3 style="color: #4CAF50;">Total : ${total.toFixed(2)} €</h3>
                <p><strong>Méthode de Paiement :</strong> ${paymentMethod}</p>

                <p>Merci pour votre commande</p>


               

                 

            </div>
        `;
        const email = adherents.find(a => a.name === adherent).email; // Récupère l'email de l'adhérent
        // Envoie l'email
        google.script.run.sendEmailToAdherent(email, invoiceEmail);
        hideLoader(); // Cacher le loader après la validation
        alert('Vente enregistrée !');
        resetForm();
        loadContent('vente'); // Revenir à la page d'accueil
    }).withFailureHandler((error) => {
        console.error("Erreur lors de l'enregistrement de la vente", error);
        hideLoader(); // Cacher le loader en cas d'erreur
        alert('Une erreur est survenue. Veuillez réessayer.');
    }).saveSale(adherent, paymentMethod, total, dateTime, purchases);
}


function getLogoUrl() {
    // Récupère l'URL de l'image depuis le CSS (contenu de #logo)
    const logoElement = document.createElement('div');
    logoElement.id = 'logo';
    document.body.appendChild(logoElement);  // Ajoute temporairement à la page pour récupérer le style
    const logoUrl = window.getComputedStyle(logoElement).getPropertyValue('content').replace(/['"]+/g, '');  // Récupère la valeur de content et retire les guillemets
    document.body.removeChild(logoElement);  // Retire l'élément temporaire
    return logoUrl;
}

function resetForm() {
    // Réinitialiser les champs de saisie
    document.getElementById('adherentsDropdown').value = '';  // Réinitialiser le dropdown des adhérents
    document.getElementById('paymentMethodDropdown').value = '';  // Réinitialiser le dropdown des méthodes de paiement
    document.getElementById('cotisationAmount').value = '';  // Réinitialiser le montant de la cotisation
    document.getElementById('creditAmount').value = '';  // Réinitialiser le montant de l'avoir
    document.getElementById('adherentEmail').innerText = '';  // Réinitialiser l'email de l'adhérent
    document.getElementById('cbFee').value = '';  // Réinitialiser les frais CB

    // Masquer le champ de l'avoir
    const creditField = document.getElementById("creditField");
    creditField.style.display = "none";  // Masquer l'avoir

    // Réinitialiser les produits sélectionnés
    const rows = document.querySelectorAll('#productList tbody tr');
    rows.forEach(row => row.remove());  // Supprimer toutes les lignes du tableau

    // Masquer le container de la cotisation
    document.getElementById('cotisationContainer').style.display = "none"; 

    // Réinitialiser d'autres éléments si nécessaire
    calculateTotal(); // Recalculer le total général
}


   function updateProductPrice(selectedOption, newPrice, priceType) {
    // Mettre à jour le prix dans l'option sélectionnée
    selectedOption.dataset.price = newPrice;
    selectedOption.value = newPrice;

    // Mettre à jour l'affichage du prix dans la cellule de prix
    const row = selectedOption.closest('tr');
    let finalPrice = newPrice;

    // Calcul du prix en fonction du type (TTC, HT à 5.5%, HT à 20%)
    if (priceType === 'HT5.5') {
        finalPrice = newPrice * 1.055; // Calculer le prix TTC pour 5.5%
    } else if (priceType === 'HT20') {
        finalPrice = newPrice * 1.20;  // Calculer le prix TTC pour 20%
    }
    
    // Mettre à jour le texte du prix avec le prix calculé
    row.cells[1].innerText = `${finalPrice.toFixed(2)} €`;

    // Recalculer le total de la ligne et le total général
    calculateRowTotal(row);
}

function openStockPopup(selectedOption) {
    if (!selectedOption) {
        alert("Veuillez sélectionner un produit avant de modifier le stock.");
        return;
    }

    const productName = selectedOption.dataset.name;
    const shortName = selectedOption.dataset.shortName;
    const barcode = selectedOption.dataset.barcode;
    const currentStock = selectedOption.dataset.stock;
    const currentPrice = selectedOption.dataset.price;
    const priceType = selectedOption.dataset.priceType || 'TTC'; // Récupérer le type de prix actuel

    // Création de la structure HTML de la popup
    const popup = document.createElement('div');
    popup.classList.add('popup-overlay'); // Utilisation de votre classe CSS existante

    // Mise à jour du contenu de la popup
    popup.innerHTML = `
        <div class="popup-content">
            <h2>Mettre à jour le produit</h2>
            <p><strong>${productName}</strong></p>
            <p><strong>Nom court :</strong>
                <input type="text" id="shortNameInput" value="${shortName}">
            </p>
            <p><strong>Code barre :</strong>
                <input type="text" id="barcodeInput" value="${barcode}">
            </p>
            <p><label for="newStock">Nouveau Stock :</label>
            <input type="number" id="newStock" value="${currentStock}" min="0"></p>
            <p><label for="newPrice">Nouveau Prix :</label>
            <input type="number" id="newPrice" value="${currentPrice}" min="0" step="0.01"></p>
            <p><label for="priceType">Type de Prix :</label>
                <select id="priceType">
                    <option value="TTC" ${priceType === 'TTC' ? 'selected' : ''}>TTC</option>
                    <option value="HT5.5" ${priceType === 'HT5.5' ? 'selected' : ''}>HT à 5.5%</option>
                    <option value="HT20" ${priceType === 'HT20' ? 'selected' : ''}>HT à 20%</option>
                </select>
            </p>
            <div class="popup-buttons">
                <md-filled-tonal-button id="saveStockButton" class="btn-save">Enregistrer</md-filled-tonal-button>
                <div></div>
                <md-filled-tonal-button id="cancelButton" class="btn-cancel">Annuler</md-filled-tonal-button>
            </div>
        </div>
    `;
    // Ajouter la popup au DOM
    document.body.appendChild(popup);

    // Enregistrer les nouvelles valeurs de stock, prix, shortName, barcode et type de prix
    document.getElementById('saveStockButton').onclick = function () {
        const newStock = parseInt(document.getElementById('newStock').value, 10);
        const newPrice = parseFloat(document.getElementById('newPrice').value);
        const newShortName = document.getElementById('shortNameInput').value;
        const newBarcode = document.getElementById('barcodeInput').value;
        const newPriceType = document.getElementById('priceType').value;
        
        // Calcul des prix TTC et HT en fonction du type de prix
        let finalPrice = newPrice;
        
        if (newPriceType === 'TTC') {
            // Si le prix est TTC, calculer le HT pour 5.5% ou 20%
            const priceHT5_5 = newPrice / 1.055;
            const priceHT20 = newPrice / 1.20;
            selectedOption.dataset.priceHT5_5 = priceHT5_5.toFixed(2);
            selectedOption.dataset.priceHT20 = priceHT20.toFixed(2);
        } else if (newPriceType === 'HT5.5') {
            // Si le prix est HT à 5.5%, calculer le TTC
            finalPrice = newPrice * 1.055;
        } else if (newPriceType === 'HT20') {
            // Si le prix est HT à 20%, calculer le TTC
            finalPrice = newPrice * 1.20;
        }
        
        // Mise à jour des données dans l'option sélectionnée
        selectedOption.dataset.stock = newStock;
        selectedOption.dataset.price = finalPrice;
        selectedOption.dataset.shortName = newShortName;
        selectedOption.dataset.barcode = newBarcode;
        selectedOption.dataset.priceType = newPriceType;

        // Mise à jour de l'affichage dans la ligne du tableau
        updateStockInRow(selectedOption);
        updateProductPrice(selectedOption, finalPrice, newPriceType);

        // Fermer la popup
        document.body.removeChild(popup);

        // Mise à jour dans Google Sheets
        updateSingleProductStockAndPrice(productName, newStock, finalPrice, newShortName, newBarcode, newPriceType);
    };

    // Annuler et fermer la popup
    document.getElementById('cancelButton').onclick = function () {
        document.body.removeChild(popup);
    };
}



    function updateStockInRow(selectedOption) {
        const rows = document.querySelectorAll('#productList tbody tr');
        rows.forEach(row => {
            const select = row.cells[0].querySelector('select');
            if (select && select.selectedOptions[0].dataset.name === selectedOption.dataset.name) {
                row.cells[2].innerText = `${selectedOption.dataset.stock} unités`; // Mettre à jour le stock
                row.cells[1].innerText = `${selectedOption.dataset.price} €`; // Mettre à jour le prix
                calculateRowTotal(row); // Recalculer le total de la ligne après modification
            }
        });
    }

    function updateSingleProductStockAndPrice(productName, newStock, newPrice, newShortName, newBarcode) {
        google.script.run.withSuccessHandler((result) => {
            alert(result); // Confirmation de mise à jour
        }).withFailureHandler((error) => {
            alert("Erreur lors de la mise à jour : " + error.message);
        }).updateProductDetails(productName, newStock, newPrice, newShortName, newBarcode);
    }

    

   
   

      ////////////////RECEPTION//////////////////////
// Fonction pour charger la liste des fournisseurs

function loadSuppliers() {
    showLoader('Chargement des producteurs'); // Affiche le loader
    google.script.run.withSuccessHandler(function(suppliers) {
        hideLoader(); // Masque le loader après le chargement
        if (!suppliers || suppliers.length === 0) {
            alert("Aucun fournisseur trouvé !");
            return;
        }

        const dropdown = document.getElementById('supplierDropdown');
        suppliers.sort((a, b) => a.name.localeCompare(b.name)); // Tri alphabétique

        const fragment = document.createDocumentFragment();
        suppliers.forEach(supplier => {
            const option = document.createElement('option');
            option.value = supplier.name;
            option.textContent = supplier.name;
            fragment.appendChild(option);
        });
        dropdown.appendChild(fragment);

        // Initialisation de Select2
        $('#supplierDropdown')
            .select2({
                placeholder: "-- Sélectionnez un producteur --",
                allowClear: true,
                width: '100%',
                minimumResultsForSearch: 0,
            })
;
    }).receptionGetSuppliers();
}



// Fonction pour ajouter une nouvelle ligne de réception
function addNewLine() {
    const newRow = document.createElement('tr');
    newRow.innerHTML = `
        <td>
            <select class="productDropdown" onchange="updatePriceAndStock(this)" disabled>
                <option value="">-- Sélectionnez un produit --</option>
            </select>
        </td>
        <td class="currentPrice"></td>
        <td><input type="number" class="priceUpdate" placeholder="Nouveau Prix" oninput="updateTotalAmount(this.parentElement.parentElement.querySelector('.receivedQuantity'))"></td>
         <td>
        <select class="priceType" onchange="updateTotalAmount(this)">
            <option value="TTC">TTC</option>
            <option value="HT5.5">HT à 5.5%</option>
            <option value="HT20">HT à 20%</option>
        </select>
    </td>
        <td class="currentStock"></td>
        <td><input type="number" class="stockUpdate" placeholder="Nouveau Stock"></td>
        <td><input type="number" class="receivedQuantity" placeholder="Quantité" oninput="updateTotalAmount(this)"></td>
        <td class="totalAmount"></td>
        <td>
            <span class="deleteRow" onclick="deleteReceptionRow(this)" style="color: red; cursor: pointer; font-size: 20px;">&times;</span>
        </td>
    `;
    document.querySelector('#receptionTable tbody').appendChild(newRow);
    
    const supplier = document.getElementById('supplierDropdown').value;
    if (supplier) {
        showLoader('Chargement des produits'); // Affiche le loader pendant le chargement des produits
        google.script.run.withSuccessHandler(function(products) {
            hideLoader(); // Masque le loader après chargement
            if (!products || products.length === 0) {
                alert("Aucun produit trouvé pour ce fournisseur !");
                return;
            }
            const productDropdown = newRow.querySelector('.productDropdown');
            // Ajouter les produits dans le dropdown du produit
            products.sort((a, b) => a.name.localeCompare(b.name));
            const fragment = document.createDocumentFragment();
            products.forEach(product => {
                const option = document.createElement('option');
                option.value = product.name;
                option.textContent = product.name;
                fragment.appendChild(option);
            });
            productDropdown.appendChild(fragment);
            
            // Initialiser Select2 une seule fois sur ce dropdown spécifique
            $(productDropdown).prop('disabled', false).select2({
                placeholder: "-- Sélectionnez un produit --",
                allowClear: true,
                minimumResultsForSearch: 1,
                width: '100%',
            });
        }).receptionGetProductsBySupplier(supplier);
    }
}


function deleteReceptionRow(element) {
    const row = element.closest('tr');
    row.parentNode.removeChild(row); // Supprime la ligne
    updateReceptionTotal(); // Mise à jour du total général après suppression
}

function updateProductDropdown() {
            const supplier = document.getElementById('supplierDropdown').value;
            // Appeler la fonction pour récupérer les produits associés au fournisseur
            google.script.run.withSuccessHandler(function(products) {
                const productDropdowns = document.querySelectorAll('.productDropdown');
                // Vérification de l'existence des éléments .productDropdown
                if (productDropdowns.length === 0) {
                    console.error("Aucun élément .productDropdown trouvé. Assurez-vous que les éléments existent avant d'appeler Select2.");
                    return;
                }
        // Trier les produits par ordre alphabétique
        products.sort((a, b) => a.name.localeCompare(b.name));
                // Mise à jour de chaque dropdown produit
                productDropdowns.forEach(dropdown => {
                    // Réinitialiser le contenu du dropdown
                    dropdown.innerHTML = '<option value="">-- Sélectionnez un produit --</option>';
                    // Ajouter chaque produit dans la liste déroulante
                    products.forEach(product => {
                        dropdown.innerHTML += `<option value="${product.name}">${product.name}</option>`;
                    });
                    // Détruire Select2 pour éviter la double initialisation s'il est déjà appliqué
                    if ($(dropdown).hasClass("select2-hidden-accessible")) {
                        $(dropdown).select2('destroy');
                    }
                    // Initialiser Select2 sur chaque dropdown de produit
                    $(dropdown).select2({
                        placeholder: "-- Sélectionnez un produit --",
                                minimumResultsForSearch: 1, // Affiche la barre de recherche sans restriction
                        allowClear: true,
                        width: '100%' ,// Adapter à la largeur du conteneur
                         matcher: function(params, data) {
                           if ($.trim(params.term) === '') {
                return data;
            }

            // Fonction pour supprimer les accents
            function removeAccents(str) {
                const accentMap = {
                    'a': 'á|à|ã|â|ä|å|æ|ã|ā',
                    'e': 'é|è|ê|ë|ē|ė',
                    'i': 'í|ì|î|ï|ī',
                    'o': 'ó|ò|ô|ö|õ|ø|ō',
                    'u': 'ú|ù|û|ü|ū',
                    'c': 'ç',
                    'n': 'ñ',
                    's': 'ś|š',
                    'z': 'ź|ž'
                };

                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Supprimer les accents
            }

            const searchWords = params.term.toLowerCase().split(/\s+/).map(word => removeAccents(word));
            const dataText = removeAccents(data.text.toLowerCase());

            const match = searchWords.every(word => dataText.includes(word));
            return match ? data : null;
        }
,
                    }).on('select2:open', () => {
            document.querySelector('.select2-search__field').focus(); // Focus dans la zone de recherche
        });
                });
                // Ajouter la première ligne si aucune ligne n'est encore présente
                const receptionTableBody = document.querySelector('#receptionTable tbody');
                if (receptionTableBody.children.length === 0) {
                    addNewLine();
                }
            })
            .withFailureHandler(function(error) {
                console.error("Erreur lors de la récupération des produits : ", error);
                alert("Erreur lors de la récupération des produits. Veuillez réessayer.");
            })
            .receptionGetProductsBySupplier(supplier);
        }
        // Fonction pour surveiller l'apparition des éléments .productDropdown
        function waitForProductDropdowns() {
            const observer = new MutationObserver((mutations, obs) => {
                const productDropdowns = document.querySelectorAll('.productDropdown');
                if (productDropdowns.length > 0) {
                    // Appeler updateProductDropdown et arrêter l'observateur
                    updateProductDropdown();
                    obs.disconnect();
                }
            });
            // Observer les changements dans le corps de la page
            observer.observe(document.body, { childList: true, subtree: true });
        }
        // Appeler la fonction d'attente au chargement de la page
        document.addEventListener("DOMContentLoaded", waitForProductDropdowns);
      ;
       
      function updatePriceAndStock(selectElement) {
    const row = selectElement.closest('tr');
    const selectedProduct = selectElement.value;
    
    google.script.run.withSuccessHandler(function(product) {
        if (product) {
            row.querySelector('.currentPrice').textContent = product.price.toFixed(2);  // Affichage du prix
            row.querySelector('.currentStock').textContent = product.stock.toFixed(2);  // Affichage du stock
            updateTotalAmount(row.querySelector('.receivedQuantity')); // Met à jour le montant total avec la quantité saisie
        } else {
            row.querySelector('.currentPrice').textContent = '';
            row.querySelector('.currentStock').textContent = '';
            row.querySelector('.totalAmount').textContent = ''; // Réinitialiser le montant total
        }
    }).withFailureHandler(function(error) {
        alert("Erreur lors de la récupération des détails du produit : " + error.message);
    }).receptionGetProductDetails(selectedProduct);
}

function updateTotalAmount(element) {
    const row = element.closest('tr');
    const receivedQuantity = row.querySelector('.receivedQuantity').value;
    let priceUpdate = row.querySelector('.priceUpdate').value || row.querySelector('.currentPrice').textContent;
    const priceType = row.querySelector('.priceType').value; // Récupérer le type de prix sélectionné

    // Si le prix est en HT, on applique la TVA
    if (priceType === 'HT5.5') {
        priceUpdate = parseFloat(priceUpdate) * 1.055; // Appliquer la TVA de 5.5%
    } else if (priceType === 'HT20') {
        priceUpdate = parseFloat(priceUpdate) * 1.20; // Appliquer la TVA de 20%
    }

    // Calcul du montant total
    const totalAmount = parseFloat(receivedQuantity) * parseFloat(priceUpdate);
    row.querySelector('.totalAmount').textContent = totalAmount.toFixed(2) + ' €';
    
    // Recalculer le total général de la réception
    updateReceptionTotal();
}


function updateReceptionTotal() {
    let total = 0;
    const rows = document.querySelectorAll('#receptionTable tbody tr');
    rows.forEach(row => {
        const totalAmount = row.querySelector('.totalAmount').textContent;
        total += parseFloat(totalAmount.replace(' €', '') || 0);
    });
    document.getElementById("totalAmount").textContent = "Total Réception : " + total.toFixed(2) + " €";
}


function validateReception() {
    showLoader('Validation de la réception');
    const rows = document.querySelectorAll('#receptionTable tbody tr');
    const receptions = [];
    const errors = []; // Tableau pour collecter les erreurs
    let isValid = true;

    rows.forEach((row, index) => {
        const productSelect = row.querySelector('.productDropdown');
        const productName = productSelect.value.trim();

        if (productName) {
            const priceUpdate = row.querySelector('.priceUpdate').value.trim() || null;
            const stockUpdate = row.querySelector('.stockUpdate').value.trim() || null;
            const receivedQuantity = row.querySelector('.receivedQuantity').value.trim() || "0";

            // Vérifier si le produit est de type "unite"
            if (productName.toLowerCase().includes("unite")) {
                if (stockUpdate && isDecimal(stockUpdate)) {
                    errors.push(`Ligne ${index + 1}: Le stock ne peut pas être une valeur décimale pour le produit "${productName}".`);
                }
                if (receivedQuantity && isDecimal(receivedQuantity)) {
                    errors.push(`Ligne ${index + 1}: La quantité reçue ne peut pas être une valeur décimale pour le produit "${productName}".`);
                }
            }

            // Convertir les valeurs si elles sont valides
            const updatedStock = stockUpdate ? parseFloat(stockUpdate) : null;
            const quantityReceived = parseFloat(receivedQuantity);

            // Vérification des champs non remplis
            if (!quantityReceived || isNaN(quantityReceived) || quantityReceived <= 0) {
                errors.push(`Ligne ${index + 1}: La quantité reçue doit être un nombre valide supérieur à 0 pour le produit "${productName}".`);
            }

            // Ajouter les données si tout est valide
            receptions.push({
                productName,
                priceUpdate,
                stockUpdate: updatedStock,
                receivedQuantity: quantityReceived
            });
        } else {
            errors.push(`Ligne ${index + 1}: Aucun produit sélectionné.`);
        }
    });

    if (errors.length > 0) {
        isValid = false;
        alert(errors.join('\n')); // Afficher toutes les erreurs en une seule alerte
    }

    if (isValid) {
        google.script.run.receptionValidateReception(receptions);
        alert('Réception enregistrée avec succès !');
        resetFormReception();
        hideLoader();
         products = null; // Invalider le cache local
        loadContent('reception'); // Revenir à la page d'accueil
    } else {
        hideLoader(); // Masquer le loader si des erreurs sont détectées
    }
}

// Fonction utilitaire pour vérifier si une valeur est décimale
function isDecimal(value) {
    return value.includes('.') && !Number.isInteger(parseFloat(value));
}


function resetFormReception() {
        document.getElementById('supplierDropdown').value = '';
        const rows = document.querySelectorAll('#receptionTable tbody tr');
        rows.forEach(row => row.remove()); // Supprimer toutes les lignes
    
    }
let selectedSupplier = "";  // Variable pour stocker le fournisseur sélectionné
// Fonction appelée à chaque changement dans la liste déroulante des fournisseurs
// Fonction appelée à chaque changement dans la liste déroulante des fournisseurs
function handleSupplierChange() {
    const supplierDropdown = document.getElementById('supplierDropdown');
    const errorMessage = document.getElementById('error-message-reception');
    const createProductButton = document.getElementById('supplierDropdownContainer');
    selectedSupplier = supplierDropdown.value;  // Stocker le fournisseur sélectionné
    if (selectedSupplier === "") {
        // Aucune sélection de fournisseur, afficher le message d'erreur
        errorMessage.style.display = 'block';
        createProductButton.disabled = true;  // Désactiver le bouton de création de produit
    } else {
        // Fournisseur sélectionné, masquer le message d'erreur et activer le bouton
        errorMessage.style.display = 'none';
        createProductButton.disabled = false;  // Activer le bouton de création de produit
        
        // Ajouter une nouvelle ligne de produit
        addNewLine(); // Cette fonction ajoutera une nouvelle ligne à la table
    }
}

// Lier cette fonction à l'événement "change" du dropdown fournisseur
document.getElementById('supplierDropdown').addEventListener('change', handleSupplierChange);

// Fonction pour ouvrir le popup de création de produit
function createNewProduct() {
    if (selectedSupplier === "") {
        alert("Sélectionnez d'abord un fournisseur");
        return;
    }
   
    // Ouvrir la popup pour créer un nouveau produit
    openCreateProductPopup();
}
// Fonction pour ouvrir la popup de création de produit
function openCreateProductPopup() {
    const supplierSelect = document.getElementById("supplierDropdown");
   
    const popupHtml = `
      <div class="popup-overlay">
        <div class="popup-content">
          <h2>Créer un nouveau produit</h2>
          <form id="createProductForm">
            <label>Nom du produit</label>
            <input type="text" id="productName" required><br><br>
           
            <label>Code-barres</label>
            <input type="text" id="productBarcode"><br><br>
            <label>Unité de mesure</label>
            <select id="productUnit" required>
              <option value="">Sélectionnez une unité</option>
              <option value="Kilo">Kilo</option>
              <option value="unite">unite</option>
              <option value="Litre">Litre</option>
            </select><br><br>
            <label>Prix</label>
            <input type="number" id="productPrice" step="0.01" required><br><br>
            <label>Quantité reçue</label>
            <input type="number" id="productQuantity" step="0.01" required><br><br>
            <button type="button" onclick="saveNewProduct()">Valider</button>
            <button type="button" onclick="closePopup()">Annuler</button>
          </form>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', popupHtml);
}

// Fonction pour enregistrer un nouveau produit
function saveNewProduct() {
    const productData = {
        name: document.getElementById('productName').value,
        barcode: document.getElementById('productBarcode').value,
        unit: document.getElementById('productUnit').value,
        price: parseFloat(document.getElementById('productPrice').value),
        quantity: parseFloat(document.getElementById('productQuantity').value),
        supplier: selectedSupplier  // Ajouter le fournisseur sélectionné
    };

    // Vérifier que tous les champs obligatoires sont remplis
    if (!productData.name || !productData.unit || !productData.price || !productData.quantity) {
        alert("Veuillez remplir tous les champs obligatoires.");
        return;
    }

    // Appel à Google Apps Script pour enregistrer le produit avec le fournisseur
    google.script.run.withSuccessHandler(response => {
        alert(response);
        closePopup();
        
        // Ajouter le nouveau produit en haut de la liste déroulante
        addProductToDropdown(productData);
    }).receptionCreateProduct(productData);  // Passer toutes les données, y compris le fournisseur
}
function addProductToDropdown(productData) {
    const supplier = selectedSupplier;
    if (!supplier) return;

    // Sélectionner tous les dropdowns de produits
    const productDropdowns = document.querySelectorAll('.productDropdown');

    // Ajouter le produit en haut de la liste de chaque dropdown produit
    productDropdowns.forEach(dropdown => {
        const newOption = document.createElement('option');
        newOption.value = productData.name;
        newOption.textContent = productData.name;

        // Insérer le nouvel élément en haut de la liste
        dropdown.insertBefore(newOption, dropdown.firstChild);

        // Appliquer Select2 à chaque dropdown
        $(dropdown).select2({
            placeholder: "-- Sélectionnez un produit --",
            minimumResultsForSearch: 1,
            allowClear: true,
            width: '100%',
        });
    });
}



    ///////FOURNISEEUR/////////////////
    function getfournisseur() {// Affiche le loader pendant le chargement
        showLoader('Chargement de la liste des fournisseurs');  // Appel à votre fonction showLoader pour afficher le loader

        // Appel à Google Apps Script pour récupérer les fournisseurs
        google.script.run.withSuccessHandler(function (suppliers) {
            // Une fois les données récupérées, affiche les fournisseurs
            displaySuppliers(suppliers);
        }).getSuppliers();  // Appel de la fonction `getSuppliers`
    }

    // Charge les fournisseurs lorsque la page est prête
    document.addEventListener("DOMContentLoaded", function () {
        loadSuppliers();  // Charge les fournisseurs au chargement de la page
    });

    // Fonction pour afficher les fournisseurs dans le tableau
    function displaySuppliers(suppliers) {
        const supplierTableBody = document.getElementById('supplierTableBody');
        supplierTableBody.innerHTML = ''; // Réinitialiser le tableau avant de remplir
        suppliers.forEach(supplier => {
            const row = document.createElement('tr');

            const supplierNameCell = document.createElement('td');
            supplierNameCell.textContent = supplier.name;
            row.appendChild(supplierNameCell);

            const emailCell = document.createElement('td');
            emailCell.textContent = supplier.email;
            row.appendChild(emailCell);

            const phoneCell = document.createElement('td');
            phoneCell.textContent = supplier.phone;
            row.appendChild(phoneCell);

            const addressCell = document.createElement('td');
            addressCell.textContent = supplier.address;
            row.appendChild(addressCell);
            const codePostalCell = document.createElement('td');
            codePostalCell.textContent = supplier.codePostal;
            row.appendChild(codePostalCell);
            const villeCell = document.createElement('td');
            villeCell.textContent = supplier.ville;
            row.appendChild(villeCell);

            const referentCell = document.createElement('td');
            referentCell.textContent = supplier.referent;
            row.appendChild(referentCell);

            supplierTableBody.appendChild(row);
        });
        // Masque le loader après avoir affiché les fournisseurs
        hideLoader();
    }

    // Fonction pour charger les référents dans le menu déroulant
    function loadReferents() {
        google.script.run.withSuccessHandler(function (referents) {
            const referentSelect = document.getElementById('supplierReferent');
            referents.forEach(function (referent) {
                const option = document.createElement('option');
                option.value = referent[0];  // Utiliser la valeur du référent
                option.textContent = referent[0];  // Afficher le nom du référent
                referentSelect.appendChild(option);
            });
        }).getReferents();
    }

    // Fonction pour ouvrir la popup de création de fournisseur
    function openCreateSupplierPopup() {
        const popupHtml = `
      <div class="popup-overlay">
        <div class="popup-content">
          <h2>Créer un nouveau fournisseur</h2>
          <form id="createSupplierForm">
            <label>Nom du fournisseur</label>
            <input type="text" id="supplierName" required><br><br>
           
            <label>Téléphone</label>
            <input type="text" id="supplierPhone" required><br><br>
           
            <label>Email</label>
            <input type="email" id="supplierEmail" required><br><br>
           
            <label>Adresse</label>
            <input type="text" id="supplierAddress" required><br><br>
           
            <label>Référent</label>
            <select id="supplierReferent" required>
                <option value="">Sélectionnez un référent</option>
                <!-- Les options des référents seront ajoutées ici -->
            </select><br><br>


            <button type="button" onclick="saveNewSupplier(event)">Valider</button>
            <button type="button" onclick="closePopup()">Annuler</button>
          </form>
        </div>
      </div>
    `;
        document.body.insertAdjacentHTML('beforeend', popupHtml);
        loadReferents();  // Charger les référents après ouverture de la popup
    }



    // Fonction pour enregistrer un nouveau fournisseur
    function saveNewSupplier(event) {
        const supplierData = {
            name: document.getElementById('supplierName') ? document.getElementById('supplierName').value : '',
            email: document.getElementById('supplierEmail') ? document.getElementById('supplierEmail').value : '',
            phone: document.getElementById('supplierPhone') ? document.getElementById('supplierPhone').value : '',
            address: document.getElementById('supplierAddress') ? document.getElementById('supplierAddress').value : '',
            codePostal: document.getElementById('suppliercodePostal') ? document.getElementById('suppliercodePostal').value : '',
            ville: document.getElementById('supplierville') ? document.getElementById('supplierville').value : '',
            referent: document.getElementById('supplierReferent') ? document.getElementById('supplierReferent').value : ''
        };


        // Vérifier que tous les champs obligatoires sont remplis
        if (!supplierData.name || !supplierData.referent) {
            alert("Veuillez renseigner au minuimum le nom et le référent.");
            return;
        }
        // Afficher le loader pendant l'enregistrement
        showLoader('Sauvegarde du nouveau fournisseur');
        // Appel à Google Apps Script pour enregistrer le fournisseur
        // Appel à Google Apps Script pour enregistrer le fournisseur
        google.script.run.withSuccessHandler(function (response) {
            alert(response); // Afficher la réponse du serveur (succès)
            closePopup(); // Fermer la popup
            getfournisseur(); // Recharger la liste des fournisseurs
            hideLoader();  // Masquer le loader après l'enregistrement
        }).createSupplier(supplierData);  // Passer toutes les données du fournisseur
    }

   

    ///////////////////////////
    ///////////////////////////
    ///////pertes///////////////
    ///////////////////////////
    ///////////////////////////

 
   function addRowPertes() {
    const lossTable = document.getElementById('lossTable').getElementsByTagName('tbody')[0];
    const row = lossTable.insertRow();
    row.style.opacity = 0;
    const cell1 = row.insertCell(0); // Colonne produit
    const cell2 = row.insertCell(1); // Colonne prix
    const cell3 = row.insertCell(2); // Colonne stock
    const cell4 = row.insertCell(3); // Colonne perte
    const cell5 = row.insertCell(4); // Colonne total
    const cell6 = row.insertCell(5); // Colonne supprimer
    // Animation de glissement
    setTimeout(() => {
        row.style.opacity = 1;
    }, 10);
    const select = document.createElement('select');
    select.classList.add('product-select');
    select.innerHTML = `<option value="">Sélectionner un produit</option>`;
    const sortedProducts = sortProducts(products);
    sortedProducts.forEach(product => {
        const option = document.createElement('option');
        option.value = product.price;
        option.dataset.price = product.price;
        option.dataset.stock = product.stock;
        option.dataset.name = product.name;
        option.textContent = product.name;
       
        select.appendChild(option);
    });
    cell1.appendChild(select);
    $(select)
    .select2({
        placeholder: 'Recherchez un produit',
        allowClear: true,
        matcher: function (params, data) {
            if ($.trim(params.term) === '') {
                return data;
            }

            // Fonction pour supprimer les accents
            function removeAccents(str) {
                const accentMap = {
                    'a': 'á|à|ã|â|ä|å|æ|ã|ā',
                    'e': 'é|è|ê|ë|ē|ė',
                    'i': 'í|ì|î|ï|ī',
                    'o': 'ó|ò|ô|ö|õ|ø|ō',
                    'u': 'ú|ù|û|ü|ū',
                    'c': 'ç',
                    'n': 'ñ',
                    's': 'ś|š',
                    'z': 'ź|ž'
                };

                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Supprimer les accents
            }

            const searchWords = params.term.toLowerCase().split(/\s+/).map(word => removeAccents(word));
            const dataText = removeAccents(data.text.toLowerCase());

            const match = searchWords.every(word => dataText.includes(word));
            return match ? data : null;
        },
        templateResult: function (option) {
            if ($(option.element).hasClass('out-of-stock')) {
                return $('<span style="color:red;">' + option.text + ' (Stock négatif)</span>');
            }
            return option.text;
        }
    })
		
		.on('select2:open', () => {
            document.querySelector('.select2-search__field').focus(); // Focus dans la zone de recherche
        });
    // Gestion de la sélection du produit
    select.onchange = function () {
        const selectedOption = select.selectedOptions[0];
        const formattedPrice = selectedOption ? parseFloat(selectedOption.dataset.price).toFixed(2) : '0.00';
        cell2.innerText = `${formattedPrice} €`;
        if (selectedOption) {
            let stockText = `${selectedOption.dataset.stock}`;
            if (!selectedOption.dataset.name.toLowerCase().includes("unite")) {
                stockText = parseFloat(selectedOption.dataset.stock).toFixed(2);
            }
            // Condition pour afficher "litres" ou "unités"
            if (selectedOption.dataset.name.toLowerCase().includes("litres")) {
                cell3.innerText = `${stockText} litres`;
            } else if (selectedOption.dataset.name.toLowerCase().includes("unite")) {
                cell3.innerText = `${stockText} unités`;
            } else if (selectedOption.dataset.name.toLowerCase().includes("kilo")) {
                cell3.innerText = `${stockText} Kg`;
            } else {
                cell3.innerText = `${stockText} unités`;
            }
            if (selectedOption.dataset.name.toLowerCase().includes("retour")) {
                cell3.innerText = "";
                row.style.backgroundColor = '#fdd';
            } else {
                row.style.backgroundColor = '';
            }
            
        } else {
            cell3.innerText = "0.00 unités";
        }
    };
    // Ajouter les autres éléments de la ligne (pertes)
    const quantityInput = document.createElement('input');
    quantityInput.type = 'number';
    quantityInput.value = 0;
    quantityInput.step = 1;
    quantityInput.min = 0;
     // Vérification de la quantité
    quantityInput.oninput = function () {
        const selectedOption = select.selectedOptions[0];
        if (selectedOption && selectedOption.dataset.name.toLowerCase().includes("unite")) {
            if (quantityInput.value.includes('.')) {
                alert("La quantité d'un produit contenant 'unite' doit être un entier.");
                quantityInput.value = Math.floor(quantityInput.value); // Forcer l'arrondi
            }
            quantityInput.step = 1; // Le pas devient 1 pour les produits "unite"
        } else {
            quantityInput.step = 0.01; // Le pas reste 0.01 pour les autres produits
        }
        calculateRowTotalPertes(row);
        calculateTotalPertes();
        
    };
    
    cell4.appendChild(quantityInput);
    // Total de la ligne (initialisé à 0)
        cell5.innerText = '0.00 €';
    const deleteIcon = document.createElement('span');
    deleteIcon.innerHTML = '❌';
    deleteIcon.style.cursor = 'pointer';
    deleteIcon.onclick = function () {
        deleteRowPertes(row);
    };
    cell6.appendChild(deleteIcon);
  
}

    function deleteRowPertes(row) {
        if (confirm("Êtes-vous sûr de vouloir supprimer cette ligne ?")) {
            const lossTable = document.getElementById('lossTable').getElementsByTagName('tbody')[0];
            lossTable.deleteRow(row.rowIndex - 1);
            calculateTotalPertes();
        }
    }
    function calculateRowTotalPertes(row) {
        const select = row.cells[0].querySelector('select');
        const quantityInput = row.cells[3].querySelector('input');
        const price = select ? parseFloat(select.value) : 0;
        const quantity = quantityInput ? parseFloat(quantityInput.value) : 0; // Remplacer parseInt par parseFloat
        row.cells[4].innerText = `${(price * quantity ).toFixed(2)} €`; // Mettre à jour le total de la ligne
        calculateTotalPertes(); // Recalculer le total général
    }

function calculateTotalPertes() {
    const rows = document.querySelectorAll('#lossTable tbody tr');
    let total = 0;
    rows.forEach(row => {
        const totalCell = row.cells[4].innerText; // Récupère la valeur dans la cellule du total de la ligne
        const rowTotal = parseFloat(totalCell.replace(' €', '').trim()) || 0; // Supprime le symbole € et calcule la valeur
        total += rowTotal; // Ajoute au total général
    });
    
    // Met à jour le total général
    document.getElementById('totalPertes').innerText = `Total Général: ${total.toFixed(2)} €`;
}



function resetFormLoss() {

   

    // Réinitialiser les produits sélectionnés
    const rows = document.querySelectorAll('#lossTable tbody tr');
    rows.forEach(row => row.remove());  // Supprimer toutes les lignes du tableau

       // Réinitialiser d'autres éléments si nécessaire
    calculateTotalPertes(); // Recalculer le total général
}

 // Valider les pertes et envoyer au backend
 function validateLosses() 
 {
      showLoader('Enregistrement des pertes'); // Affiche le loader

    const rows = document.querySelectorAll('#lossTable tbody tr');
    const pertes = [];

    rows.forEach(row => {
        const select = row.querySelector('select'); // Récupère le select du produit
        const quantityInput = row.querySelector('input'); // Récupère l'input de la quantité
        const price = parseFloat(select ? select.dataset.price : 0); // Récupère le prix du produit
        const productName = select ? select.options[select.selectedIndex].text : ''; // Récupère le nom du produit
        const lossQuantity = parseFloat(quantityInput ? quantityInput.value : 0); // Récupère la quantité

        if (productName && lossQuantity > 0) {
            pertes.push({
                productName: productName,
                lossQuantity: lossQuantity,
                lossAmount: (price * lossQuantity).toFixed(2), // Calcul du montant
            });
        }
    });

if (pertes.length > 0) {
        google.script.run
            .withSuccessHandler(() => {
                alert('Pertes validées avec succès !');
                resetFormLoss(); // Appeler resetFormLoss après validation
                hideLoader();
            })
            .validateLoss(pertes); // Envoie les pertes au backend
    } else {
        alert('Veuillez renseigner les pertes correctement.');
    }
}





    ///////////////INVENTAIRE//////////////////
    let products = [];  // Liste des produits
    let isProductsLoaded = false;  // Indicateur pour vérifier si les produits sont chargés


    // Mettre à jour les données d'une ligne avec la date d'inventaire
    function updateRowData(row, productName) {
        const product = products.find(p => p.name === productName);
        if (product) {
            // Mettre à jour le prix et le stock
            row.querySelector('.price-cell').textContent = product.price.toFixed(2); // Prix
            row.querySelector('.stock-cell').textContent = product.stock.toFixed(2); // Stock actuel

            // Assurer que la date d'inventaire existe
            const inventoryDate = product.stockDate || 'Aucune date'; // Si pas de date, afficher 'Aucune date'
            console.log("Mise à jour de la date d'inventaire pour", product.name, inventoryDate);

            // Sélectionner la cellule pour la date et y insérer la date d'inventaire
            const dateCell = row.querySelector('.last-delivery-date');
            if (dateCell) {
                dateCell.textContent = inventoryDate; // Afficher la date
            } else {
                console.error('La cellule de la date n\'a pas été trouvée.');
            }

        }
    }

    // Fonction d'ajout d'une ligne dans le tableau avec Select2
    function addRowInventaire() {
        const template = document.getElementById('rowTemplate');
        const productRows = document.getElementById('productRows');
        const clone = template.content.cloneNode(true); // Cloner le template
        const selectElement = clone.querySelector('.product-select');

        // Ajouter une option vide pour le placeholder
        const emptyOption = document.createElement('option');
        emptyOption.value = '';  // Valeur vide
        emptyOption.textContent = 'Sélectionnez un produit';  // Texte du placeholder
        selectElement.appendChild(emptyOption);  // Ajouter cette option au <select>

        // Configurer Select2 une seule fois si les produits sont chargés
        if (isProductsLoaded) {
            $(selectElement)
                .select2({
                    data: products.map(product => ({ id: product.name, text: product.name })),
                    placeholder: "Sélectionnez un produit",
                    allowClear: true,
                    width: '100%', 
                   matcher: function (params, data) {
            if ($.trim(params.term) === '') {
                return data;
            }

            // Fonction pour supprimer les accents
            function removeAccents(str) {
                const accentMap = {
                    'a': 'á|à|ã|â|ä|å|æ|ã|ā',
                    'e': 'é|è|ê|ë|ē|ė',
                    'i': 'í|ì|î|ï|ī',
                    'o': 'ó|ò|ô|ö|õ|ø|ō',
                    'u': 'ú|ù|û|ü|ū',
                    'c': 'ç',
                    'n': 'ñ',
                    's': 'ś|š',
                    'z': 'ź|ž'
                };

                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(); // Supprimer les accents
            }

            const searchWords = params.term.toLowerCase().split(/\s+/).map(word => removeAccents(word));
            const dataText = removeAccents(data.text.toLowerCase());

            const match = searchWords.every(word => dataText.includes(word));
            return match ? data : null;
        },
                })
                .on('change', function () {
                    const selectedProductName = this.value;
                    if (selectedProductName) {
                        updateRowData(this.closest('tr'), selectedProductName);
                        addRowInventaire(); // Ajouter une nouvelle ligne après sélection
                    }
                })
                .on('select2:open', function () {
                    // Mettre le focus sur la zone de recherche après ouverture du Select2
                    const searchInput = document.querySelector('.select2-search__field');
                    if (searchInput) {
                        searchInput.focus();
                    }
                })
                .val('');

            productRows.appendChild(clone); // Ajouter la ligne au tableau
        }
    }

    // Charger les produits depuis Google Sheets et préparer l'affichage
    function getProductsFromSheet() {
        showLoader('Chargement des produits'); // Afficher le loader pendant le chargement
        google.script.run.withSuccessHandler(function (data) {
            products = data.map(product => {
                // Assurer que stockDate existe ou est défini
                return {
                    name: product.name,
                    price: product.price,
                    shortName: product.shortName,
                    supplier: product.supplier,
                    barcode: product.barcode,
                    stock: product.stock,
                    stockDate: product.stockDate || 'Aucune date' // Valeur par défaut si stockDate est vide
                };
            });
            isProductsLoaded = true;
            addRowInventaire(); // Ajouter la première ligne automatiquement
            hideLoader(); // Cacher le loader une fois terminé
        }).getProducts();
    }

    // Fonction pour enregistrer l'inventaire
    function saveInventory() {
    showLoader('Enregistrement de l inventaire');  // Afficher le loader pendant le processus de sauvegarde

    const today = new Date();
    const formattedDate = today.toLocaleDateString('fr-FR'); // Format JJ/MM/AAAA

    const productRows = document.querySelectorAll('#productRows tr');
    const updatedProducts = [];

    // Récupérer les noms des produits inventoriés
    const inventoriedProductNames = [];

    // Préparer les données pour l'enregistrement
    productRows.forEach(row => {
        const productSelect = row.querySelector('.product-select');
        const stockUpdateInput = row.querySelector('.stock-update');
        const productName = productSelect.value;
        const newStock = stockUpdateInput.value ? parseFloat(stockUpdateInput.value) : 0;

        if (productName) {
            inventoriedProductNames.push(productName);

            const product = products.find(p => p.name === productName);

            if (product) {
                updatedProducts.push({
                    name: productName,
                    price: product.price,
                    stock: newStock,
                    date: formattedDate
                });
            } else {
                console.error('Produit non trouvé :', productName);
            }
        }
    });

    // Ajouter les produits non inventoriés avec stock = 0
    products.forEach(product => {
        if (!inventoriedProductNames.includes(product.name)) {
            updatedProducts.push({
                name: product.name,
                price: product.price,
                stock: 0,
                date: formattedDate
            });
        }
    });

    if (updatedProducts.length > 0) {
        // Étape 1 : Enregistrer les données dans Google Sheets
        google.script.run.withSuccessHandler(function () {
            console.log('Données enregistrées avec succès.');

            // Étape 2 : Calculer le total des produits avec la date d'aujourd'hui
            calculateTotalForToday(formattedDate);
            resetInventoryRows();
        }).updateInventory(updatedProducts);
    } else {
        hideLoader();
        alert('Aucun produit sélectionné pour l\'enregistrement.');
    }
}

    // Fonction pour enregistrer l'inventaire
    function saveInventoryWithoutMail() {
        showLoader('Validation de l inventaire');  // Afficher le loader pendant le processus de sauvegarde

        const today = new Date();
        const formattedDate = today.toLocaleDateString('fr-FR'); // Format JJ/MM/AAAA

        const productRows = document.querySelectorAll('#productRows tr');
        const updatedProducts = [];

        // Préparer les données pour l'enregistrement
        productRows.forEach(row => {
            const productSelect = row.querySelector('.product-select');
            const stockUpdateInput = row.querySelector('.stock-update');
            const productName = productSelect.value;
            const newStock = stockUpdateInput.value ? parseFloat(stockUpdateInput.value) : 0;

           
        if (productName) {
            inventoriedProductNames.push(productName);

            const product = products.find(p => p.name === productName);

            if (product) {
                updatedProducts.push({
                    name: productName,
                    price: product.price,
                    stock: newStock,
                    date: formattedDate
                });
            } else {
                console.error('Produit non trouvé :', productName);
            }
        }
    });

    // Ajouter les produits non inventoriés avec stock = 0
    products.forEach(product => {
        if (!inventoriedProductNames.includes(product.name)) {
            updatedProducts.push({
                name: product.name,
                price: product.price,
                stock: 0,
                date: formattedDate
            });
        }
    });


        if (updatedProducts.length > 0) {
            // Étape 1 : Enregistrer les données dans Google Sheets
            google.script.run.withSuccessHandler(function () {
                console.log('Données enregistrées avec succès.');

                // Étape 2 : Calculer le total des produits avec la date d'aujourd'hui
                resetInventoryRows();
                loadContent('inventaire');
                            hideLoader();



            }).updateInventory(updatedProducts);
        } else {
            hideLoader();
            alert('Aucun produit sélectionné pour l\'enregistrement.');
        }
    }

// Fonction pour réinitialiser les lignes de l'inventaire
function resetInventoryRows() {
    const productRows = document.querySelector('#productRows');
    productRows.innerHTML = ''; // Supprimer toutes les lignes existantes
    addRowInventaire(); // Ajouter une nouvelle ligne vide
}
    function calculateTotalForToday(formattedDate) {
        // Appeler la fonction côté serveur pour récupérer les données filtrées et calculer le total
        google.script.run.withSuccessHandler(function (total) {
            console.log('Total calculé :', total);

            // Étape 3 : Envoyer un email avec le montant total
            google.script.run.sendInventoryEmail(formattedDate, total);

            alert(`Inventaire enregistré avec succès. Total : ${total}€`);
            hideLoader();

            // Revenir à la page d'accueil
            loadContent('inventaire');
        }).getTotalForDate(formattedDate);
    }



////////ETIQUETTES//////////


function addRowEtiquettes() {
    const labelTable = document.getElementById('labelTable').getElementsByTagName('tbody')[0];
    const row = labelTable.insertRow();
    row.style.opacity = 0;

    const cell1 = row.insertCell(0); // Colonne produit
    const cell2 = row.insertCell(1); // Colonne short name
    const cell3 = row.insertCell(2); // Colonne fournisseur
    const cell4 = row.insertCell(3); // Colonne prix
    const cell5 = row.insertCell(4); // Colonne Code Barre

    // Animation de glissement
    setTimeout(() => {
        row.style.opacity = 1;
    }, 10);

    // Création de la liste déroulante pour les produits
    const select = document.createElement('select');
    select.classList.add('product-select');
    select.innerHTML = `<option value="">Sélectionner un produit</option>`;

    // Tri et ajout des produits dans la liste déroulante
    const sortedProducts = sortProducts(products);
    sortedProducts.forEach(product => {
        const option = document.createElement('option');
        option.value = product.price; // Valeur = prix
        option.dataset.price = product.price; // Stocker le prix
        option.dataset.name = product.name; // Stocker le nom
        option.textContent = product.name; // Afficher le nom
        option.dataset.shortName = product.shortName;
        option.dataset.supplier = product.supplier;
        option.dataset.barcode = product.barcode;
        select.appendChild(option);
    });

    // Ajouter la liste déroulante à la première cellule
    cell1.appendChild(select);

    
    // Ajouter un gestionnaire d'événement pour mettre à jour le prix
    select.onchange = function () {
    const selectedOption = select.selectedOptions[0];
     const formattedPrice = selectedOption ? parseFloat(selectedOption.dataset.price).toFixed(2) : '0.00';
        cell2.innerText = selectedOption ? selectedOption.dataset.shortName : ''; // Affiche le fournisseur
        cell3.innerText = selectedOption ? selectedOption.dataset.supplier : ''; // Affiche le fournisseur
        cell4.innerText = `${formattedPrice} €`; // Affiche le prix formaté
        cell5.innerText = selectedOption ? selectedOption.dataset.barcode : ''; // Affiche le code-barres

          // Crée une nouvelle ligne après la sélection du produit
        addRowEtiquettes(); // Appelle la fonction pour ajouter une nouvelle ligne
};

 $(select).select2({
        placeholder: 'Recherchez un produit',
        allowClear: true,
        matcher: function (params, data) {
            if ($.trim(params.term) === '') {
                return data;
            }

            function removeAccents(str) {
                return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
            }

            const searchWords = params.term.toLowerCase().split(/\s+/).map(removeAccents);
            const dataText = removeAccents(data.text.toLowerCase());

            const match = searchWords.every(word => dataText.includes(word));
            return match ? data : null;
        },
        templateResult: function (option) {
            if ($(option.element).hasClass('out-of-stock')) {
                return $('<span style="color:red;">' + option.text + ' (Stock négatif)</span>');
            }
            return option.text;
        }
    })
     .on('select2:open', () => {
        document.querySelector('.select2-search__field').focus(); // Focus dans la zone de recherche
    })
    .trigger('open'); // Ouvre la liste déroulante immédiatement après sa création
}

function openPreviewWindow(content) {
    // Ouvrir une nouvelle fenêtre
    const printWindow = window.open('', '_blank');

    // CSS injecté directement dans le contenu de la nouvelle fenêtre
    const cssStyles = `
       body {
    font-family: Arial, sans-serif;
    margin: 20px;
}

.page {
    display: flex;
    flex-wrap: wrap;
    gap: 10px; /* Espacement entre les étiquettes */
}

.etiquette {
    width: 8cm; /* Largeur de l'étiquette */
    height: 4cm; /* Hauteur de l'étiquette */
    border: 2px solid black; /* Bordure de 2px autour de chaque étiquette */
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* Espace entre les éléments */
    background-color: #fff; /* Fond blanc */
    page-break-inside: avoid; /* Empêche la coupure d'étiquette entre les pages */
}

.short-name {
    font-size: 3vw; /* Taille du nom du produit relative à la largeur de l'étiquette */
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: 5px;
    text-align: left;
    white-space: nowrap; /* Empêche la coupe du texte */
    overflow: hidden;
    text-overflow: ellipsis; /* Ajoute des points de suspension si le texte est trop long */
    flex-shrink: 1; /* Permet au nom de se réduire si nécessaire */
}

.details {
    font-size: 2vw; /* Taille pour le fournisseur relative à la largeur de l'étiquette */
    text-transform: uppercase;
    margin-bottom: 5px;
    text-align: left;
    white-space: nowrap; /* Empêche la coupure du texte */
    overflow: hidden;
    text-overflow: ellipsis; /* Ajoute des points de suspension si le texte est trop long */
}

.price-barcode {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    min-height: 30px; /* Hauteur minimale pour cette ligne */
}

.barcode {
    font-size: 2vw; /* Taille du code barre en fonction de la largeur de l'étiquette */
    text-align: left;
    visibility: visible; /* Par défaut, le code barre est visible */
    flex-shrink: 1; /* Permet au code barre de rétrécir si nécessaire */
    word-wrap: break-word; /* Permet de casser les mots longs si nécessaire */
    max-width: 50%; /* Limite la largeur du code barre pour qu'il ne prenne pas trop de place */
}

.price {
    font-size: 5vw; /* Taille du prix en fonction de la largeur de l'étiquette */
    font-weight: bold;
    text-align: right;
    flex-shrink: 1; /* Permet au prix de se réduire si nécessaire */
    margin-left: 10px; /* Un petit espacement entre le code barre et le prix */
    max-width: 50%; /* Limite la largeur du prix pour qu'il ne prenne pas trop de place */
}

.etiquette .barcode:empty {
    visibility: hidden; /* Cache le code barre si vide */
        display: none; /* Supprime complètement l'espace réservé pour le code barre */

}

.etiquette .price-barcode {
    justify-content: space-between; /* Toujours espacer le code barre et le prix */
}

.etiquette .barcode {
    margin-right: 0; /* Supprimer la marge si pas de code barre */
}



    `;

    // Contenu HTML à injecter
    const html = `
        <html>
        <head>
            <title>Aperçu des Étiquettes</title>
            <style>${cssStyles}</style> <!-- Ajout du CSS directement ici -->
        </head>
        <body>
            ${content}
        </body>
        </html>
    `;

    // Écrire le contenu HTML dans la nouvelle fenêtre
    printWindow.document.open();
    printWindow.document.write(html);
    printWindow.document.close();

    // Ajouter dynamiquement le script pour générer les codes-barres
    printWindow.onload = function () {
    const scriptBarcode = printWindow.document.createElement('script');
    scriptBarcode.src = "https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js";
    scriptBarcode.onload = () => {
        // Attendre un petit délai pour s'assurer que le DOM est chargé
        setTimeout(() => {
            const barcodes = printWindow.document.querySelectorAll('.barcode');
            const rows = document.querySelectorAll('#labelTable tr'); // Sélectionner toutes les lignes du tableau

            // Parcourir les codes-barres et appliquer le bon code-barres à chaque étiquette
            barcodes.forEach((barcode, index) => {
                const row = rows[index + 1]; // Ignorer la première ligne du tableau (en-tête)
                const cells = row.getElementsByTagName('td');
                
                // Vérifier si la ligne et les cellules sont valides
                if (cells.length > 4) {
                    const barcodeValue = cells[4]?.textContent.trim() || ''; // Obtenir la valeur du code-barres

                    // Nettoyer la valeur du code-barres
                    const cleanedBarcodeValue = barcodeValue.replace(/\D/g, ''); // Supprimer tous les caractères non numériques
                    const numericBarcodeValue = Number(cleanedBarcodeValue);

                    // Vérifier si le code-barres est valide (doit avoir une longueur de 13 chiffres)
                    if (numericBarcodeValue && cleanedBarcodeValue.length === 13) {
                        JsBarcode(barcode, cleanedBarcodeValue, {
                            format: 'EAN13',
                            width: 2,
                            height: 50,
                            displayValue: true, // Afficher la valeur du code-barres
                        });
                    } else {
                        console.error("Code-barres invalide ou trop court:", cleanedBarcodeValue);
                    }
                }
            });

            // Lancer l'impression après que tout soit prêt
            printWindow.print();
        }, 100); // Un petit délai pour s'assurer que le DOM est bien prêt
    };
    printWindow.document.body.appendChild(scriptBarcode);
};


}


function generateEtiquettes() {
    // Récupérer les données du tableau des produits
    const table = document.getElementById('labelTable');
    const rows = table.getElementsByTagName('tr');

    // Création des étiquettes en HTML
    const etiquettesHTML = createEtiquettesHTML(rows);

    // Ouvrir une nouvelle fenêtre pour l'aperçu
    openPreviewWindow(etiquettesHTML);
}

function createEtiquettesHTML(rows) {
    let html = `<div class="page">`;

    // Parcourir les lignes du tableau et générer les étiquettes
    for (let i = 1; i < rows.length; i++) { // Commencer à 1 pour ignorer l'en-tête
        const cells = rows[i].getElementsByTagName('td');
        if (cells.length > 0) {
            const shortName = cells[1].innerText || '';
            const supplier = cells[2].innerText || '';
            const price = cells[3].innerText || '';
            const barcodeValue = cells[4].innerText || '';

            html += `
                <div class="etiquette">
                    <div class="short-name">${shortName}</div>
                    <div class="details"> ${supplier}</div>
                                       <div class="price-barcode">

                    <svg class="barcode"></svg> <!-- Code barre sous forme de SVG -->
                    <div class="price">${price}</div>
                </div>
                </div>
            `;
        }
    }

    html += `</div>`; // Fermeture du conteneur principal
    return html;
}



    // Initialisation
    document.addEventListener('DOMContentLoaded', function () {
        getProductsFromSheet(); // Charger les produits au démarrage
    });
    // Charger les produits et les adhérents lors du chargement de la page
    $(document).ready(function () {

    });
</script>
